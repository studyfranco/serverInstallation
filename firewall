#! /bin/bash
### BEGIN INIT INFO
# Provides:          firewall
# Required-Start:    $local_fs $remote_fs $syslog
# Required-Stop:     $local_fs $remote_fs
# Should-Start:      iptables
# Should-Stop:       iptables
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start/stop firewall
# Description:       Start/stop firewall, a script to set/unset your custom fir
### END INIT INFO

CHAINIPALLOW="z-allow-ips"
CHAINIPALLOWTCP="z-allow-ips-tcp"
CHAINIPALLOWUDP="z-allow-ips-udp"

CHAINICMPTRAFIC="z-icmp"

CHAINDROPLOG="z-drop-log"
CHAINDROPLOGSELECTOR="z-drop-log-select-trash"
CHAINDROPLOGWITHOUTSELECTOR="z-drop-log-no-select-trash"

CHAINPORTSENTRYOPENTCP="z-port-sentry-open-tcp"
CHAINPORTSENTRYOPENUDP="z-port-sentry-open-udp"
CHAINPORTSENTRYCLOSETCP="z-port-sentry-close-tcp"
CHAINPORTSENTRYCLOSEUDP="z-port-sentry-close-udp"
CHAINPORTSENTRYLOG="z-port-sentry-log"

CHAINOPENSATE="z-open-state"
CHAINOUTTRAFIC="z-output-rules"

CHAINMAININTER="zz"

CHAINMAINOUTINTERICMP="z-main-out-icmp"
CHAINOPENDHCP="z-open-port-dhcp"

CHAINOPENLOCALPORTTCP="z-open-local-tcp"
CHAINOPENLOCALPORTUDP="z-open-local-udp"
CHAINOPENLOCALPORTUDPDHCP="z-open-local-udp-dhcp"

CHAINMAINOUTINTERCR="z-main-out-cr"
CHAINOPENCRPORTTCP="z-main-out-cr-open-tcp"
CHAINOPENCRPORTUDP="z-main-out-cr-open-udp"

CHAINMAINOUTINTERWW="z-main-out-ww"
CHAINOPENWWPORTTCP="z-main-out-ww-open-tcp"
CHAINOPENWWPORTUDP="z-main-out-ww-open-udp"

CHAINMAININTINTERICMP="z-main-inter-icmp"
CHAINMAININTINTERTCP="z-main-inter-tcp"
CHAINMAININTINTERUDP="z-main-inter-udp"
CHAINMAININTINTERUDPDHCP="z-main-inter-udp-dhcp"

CHAINDROPCAST="z-drop-cast"
CHAINMAINOUTINTERDROPBADIPSRC="z-main-out-drop-bad-ip-src"
CHAINMAINOUTINTERLOGBADIPDST="z-main-out-log-bad-ip-dst"
CHAINMAINOUTINTERLOGBADIPDSTWB="z-main-out-log-dst-bad-ip"
CHAINMAINOUTINTERLOGBADIPDSTWC="z-main-out-log-dst-crowd-ip"

CHAINFORWARDFILTER="FORWARD-TRAFIC-FILTER"
CHAINFORWARDFILTERTCP="FORWARD-TRAFIC-FILTER-TCP"
CHAINFORWARDFILTERUDP="FORWARD-TRAFIC-FILTER-UDP"
CHAINFORWARDFILTERICMP="FORWARD-TRAFIC-FILTER-ICM"
CHAINFORWARDTRAFIC="FORWARD-TRAFIC"

declare -a SPECIALCHAINLIST=($CHAINIPALLOW
				$CHAINMAINOUTINTERCR $CHAINOPENCRPORTTCP $CHAINOPENCRPORTUDP
				$CHAINMAINOUTINTERWW $CHAINOPENWWPORTTCP $CHAINOPENWWPORTUDP
				$CHAINOPENLOCALPORTTCP $CHAINOPENLOCALPORTUDP $CHAINOPENLOCALPORTUDPDHCP
				$CHAINMAININTINTERTCP $CHAINMAININTINTERUDP $CHAINMAININTINTERUDPDHCP $CHAINMAININTINTERICMP
				$CHAINMAINOUTINTERICMP $CHAINOPENDHCP
				$CHAINPORTSENTRYOPENTCP $CHAINPORTSENTRYOPENUDP $CHAINPORTSENTRYCLOSETCP $CHAINPORTSENTRYCLOSEUDP $CHAINPORTSENTRYLOG
				$CHAINFORWARDFILTER $CHAINFORWARDTRAFIC $CHAINFORWARDFILTERTCP $CHAINFORWARDFILTERUDP ${CHAINFORWARDFILTERICMP} ${CHAINFORWARDTRAFIC}-from ${CHAINFORWARDTRAFIC}-to
				$CHAINOPENSATE $CHAINOUTTRAFIC $CHAINDROPLOG $CHAINDROPLOGSELECTOR $CHAINDROPLOGWITHOUTSELECTOR
				$CHAINMAINOUTINTERDROPBADIPSRC $CHAINMAINOUTINTERLOGBADIPDST $CHAINMAINOUTINTERLOGBADIPDSTWB $CHAINMAINOUTINTERLOGBADIPDSTWC $CHAINDROPCAST)

CHAINPATMAIN="z-redirect-main"
CHAINPATLOG="z-redirect-log"
CHAINPOSTROUTINGNAT="NAT-TRAFIC"
declare -a NATCHAINLIST=(${CHAINPATMAIN} ${CHAINPOSTROUTINGNAT}
				${CHAINIPALLOW} ${CHAINIPALLOWTCP} ${CHAINIPALLOWUDP} ${CHAINIPALLOWTCP}-logs ${CHAINIPALLOWUDP}-logs
				${CHAINMAINOUTINTERCR} ${CHAINOPENCRPORTTCP} ${CHAINOPENCRPORTUDP} ${CHAINOPENCRPORTTCP}-logs ${CHAINOPENCRPORTUDP}-logs
				${CHAINMAINOUTINTERWW} ${CHAINOPENWWPORTTCP} ${CHAINOPENWWPORTUDP} ${CHAINOPENWWPORTTCP}-logs ${CHAINOPENWWPORTUDP}-logs
				${CHAINOPENLOCALPORTTCP} ${CHAINOPENLOCALPORTUDP} ${CHAINOPENLOCALPORTUDPDHCP} ${CHAINOPENLOCALPORTTCP}-logs ${CHAINOPENLOCALPORTUDP}-logs ${CHAINOPENLOCALPORTUDPDHCP}-logs
				${CHAINMAININTINTERTCP} ${CHAINMAININTINTERUDP} ${CHAINMAININTINTERUDPDHCP} ${CHAINMAININTINTERTCP}-logs ${CHAINMAININTINTERUDP}-logs ${CHAINMAININTINTERUDPDHCP}-logs
				${CHAINPATLOG})

source /etc/firewall/firewall.settings
#
# Function that set the firewall rules
#
set_rules()
{
	local pid1
	echo "Réglages principaux des interfaces"
	insert_rules "-P INPUT ACCEPT" && insert_rules "-F INPUT" && insert_rules "-A INPUT -i lo -j ACCEPT" && insert_rules "-P INPUT DROP" & pid1=$!
	insert_rules "-P FORWARD DROP" &
	insert_rules "-I OUTPUT 1 -o lo -j ACCEPT" &
	
	insert_rules_quietly "-t raw -N $CHAINICMPTRAFIC" && \
		$IPT -t raw -A PREROUTING -p icmp -j $CHAINICMPTRAFIC && \
		$IPT -t raw -A $CHAINICMPTRAFIC -p icmp -m u32 ! --u32 "4&0x3FFF=0" -j DROP && \
		$IPT -t raw -A $CHAINICMPTRAFIC -p icmp -m length --length 1492:65535 -j DROP &

	declare -a pidsI=()
	for chain in "${SPECIALCHAINLIST[@]}"; do
		insert_rules_quietly "-N $chain" & pidsI+=($!)
	done

	declare -a pidsN=()
	for chain in "${NATCHAINLIST[@]}"; do
		insert_rules_quietly "-t nat -N $chain" & pidsN+=($!)
	done

	local pid2
	generate_set_ip_net ${interfaceToGoOutSide[@]} ${internInterfaceHaveAccessAsLocal[@]} ${INTEROut[@]} & pid2=$!
	
	# On souhaite que nos VM puissent avoir internet rapidement. Il faut donc paramétrer rapidement de forwading
	insert_rules "-t nat -I POSTROUTING 1 -o $mainInter -j MASQUERADE" && \
	insert_rules "-t nat -I POSTROUTING 1 -m addrtype --dst-type MULTICAST -j RETURN" && insert_rules_quietly "-t nat -I POSTROUTING 1 -m addrtype --dst-type BROADCAST -j RETURN" && \
	insert_rules "-t nat -I POSTROUTING 1 -m addrtype --src-type MULTICAST -j RETURN" && insert_rules_quietly "-t nat -I POSTROUTING 1 -m addrtype --src-type BROADCAST -j RETURN" && \
	insert_rules "-t nat -I POSTROUTING 1 -m addrtype --dst-type local -j RETURN" && insert_rules "-t nat -I POSTROUTING 1 -m addrtype --src-type local -j RETURN" && \
	insert_rules_with_test_ok_ipv4 "-t nat -I POSTROUTING 1 -d 224.0.0.0/24 -j RETURN" "" && insert_rules_with_test_ok_ipv4 "-t nat -I POSTROUTING 1 -d 255.255.255.255 -j RETURN" "" &

	declare -a pidsInp=()
	declare -a pidsNat=()
	declare -a pidsToWaitForLinkFowardRules=()
	local INTER
	local INTERC
	wait $pid1
	wait "${pidsI[@]}"
	# On autorise les connexions dont l état est RELATED ou ESTABLISHED des packets
	# On fais en sorte que les IPs autorisé puisse enfin avoir de la connectivité
	echo "Réglages pour la continuité de reception"
	$IPT -I INPUT 2 -j $CHAINOPENSATE && insert_rules_with_test_ok_ipv4 "-A INPUT -m set --match-set $IPSLISTGOODIP src -g $CHAINIPALLOW" "" & pidsInp+=($!)
	$IPT6 -I INPUT 2 -j $CHAINOPENSATE && insert_rules_with_test_ok_ipv6 "-A INPUT -m set --match-set ${IPSLISTGOODIP}6 src -g $CHAINIPALLOW" "" & pidsInp+=($!)
	
	# Creation des etats possibles
	insert_rules "-A $CHAINOPENSATE -m state --state ESTABLISHED,RELATED -j ACCEPT" &
	insert_rules "-A $CHAINOPENSATE -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT" &
	
	wait "${pidsN[@]}"
	# Après ce petit temps de configuration, nous pouvons rediriger les main
	insert_rules_with_test_ok "-t nat -I PREROUTING -m addrtype --dst-type local -j $CHAINPATMAIN" "-t nat -I PREROUTING -j $CHAINPATMAIN" &
	# On prépare déjà le cas des redirections pour l'interface local
	$IPT -t nat -A $CHAINPATMAIN -i lo -j $CHAINIPALLOW && insert_rules_with_test_ok_ipv4 "-t nat -A $CHAINPATMAIN -m set --match-set $IPSLISTGOODIP src -g $CHAINIPALLOW" "" & pidsNat+=($!)
	$IPT6 -t nat -A $CHAINPATMAIN -i lo -j $CHAINIPALLOW && insert_rules_with_test_ok_ipv6 "-t nat -A $CHAINPATMAIN -m set --match-set ${IPSLISTGOODIP}6 src -g $CHAINIPALLOW" "" & pidsNat+=($!)
	# Preparation du log pour la chain pat
	insert_rules "-t nat -A ${CHAINPATLOG} -j NFLOG --nflog-threshold 5 --nflog-group 63" &
	
	insert_rules "-A ${CHAINFORWARDTRAFIC} -j ${CHAINFORWARDTRAFIC}-from" &
	insert_rules "-A ${CHAINFORWARDTRAFIC} -j ${CHAINFORWARDTRAFIC}-to" &
	# On souhaite que nos VM puissent avoir internet rapidement. Il faut donc paramétrer rapidement de forwading
	#insert_rules "-t nat -I POSTROUTING 1 -j $CHAINPOSTROUTINGNAT" &
	wait $pid2
	for INTER in "${interfaceToGoOutSide[@]}"; do
		# inter,net/mask,net6/mask
		insert_rules_nat_forward_interface $INTER & pidsToWaitForLinkFowardRules+=($!)
	done
	insert_set_ip_net ${interfaceToGoOutSide[@]} ${internInterfaceHaveAccessAsLocal[@]} ${INTEROut[@]} &

	# On génère les règles de filtrage pour les interfaces vers l'exterieur
	insert_rules_with_test_ok_ipv4 "-A $CHAINMAINOUTINTERDROPBADIPSRC -m set --match-set $IPSLISTBADIP src -j DROP" "" &
	insert_rules_with_test_ok_ipv6 "-A $CHAINMAINOUTINTERDROPBADIPSRC -m set --match-set ${IPSLISTBADIP}6 src -j DROP" "" &
	insert_rules_with_test_ok_ipv4 "-A $CHAINMAINOUTINTERDROPBADIPSRC -m set --match-set crowdsec-blacklists src -j DROP" "" &
	insert_rules_with_test_ok_ipv6 "-A $CHAINMAINOUTINTERDROPBADIPSRC -m set --match-set crowdsec6-blacklists src -j DROP" "" &

	#-j LOG --log-prefix [iptables-warning]:badIP  --log-level 7 --log-uid --log-ip-options
	insert_rules "-A $CHAINMAINOUTINTERLOGBADIPDSTWB -j NFLOG --nflog-prefix badIP: --nflog-threshold 5 --nflog-group 62" && \
		insert_rules "-A $CHAINMAINOUTINTERLOGBADIPDSTWB -j NFLOG --nflog-prefix badIP: --nflog-threshold 5 --nflog-group 65 --nflog-size 65531" && \
		insert_rules "-A $CHAINMAINOUTINTERLOGBADIPDSTWB -j CONNMARK --set-mark 1" &
	insert_rules "-A $CHAINMAINOUTINTERLOGBADIPDSTWC -j NFLOG --nflog-prefix crowdsec: --nflog-threshold 5 --nflog-group 62" && \
		insert_rules "-A $CHAINMAINOUTINTERLOGBADIPDSTWC -j NFLOG --nflog-prefix crowdsec: --nflog-threshold 5 --nflog-group 65 --nflog-size 65531" && \
		insert_rules "-A $CHAINMAINOUTINTERLOGBADIPDSTWC -j CONNMARK --set-mark 1" &
	insert_rules_with_test_ok_ipv4 "-A $CHAINMAINOUTINTERLOGBADIPDST -m set --match-set $IPSLISTBADIP dst -g $CHAINMAINOUTINTERLOGBADIPDSTWB" "" &
	insert_rules_with_test_ok_ipv6 "-A $CHAINMAINOUTINTERLOGBADIPDST -m set --match-set ${IPSLISTBADIP}6 dst -g $CHAINMAINOUTINTERLOGBADIPDSTWB" "" &
	insert_rules_with_test_ok_ipv4 "-A $CHAINMAINOUTINTERLOGBADIPDST -m set --match-set crowdsec-blacklists dst -g $CHAINMAINOUTINTERLOGBADIPDSTWC" "" &
	insert_rules_with_test_ok_ipv6 "-A $CHAINMAINOUTINTERLOGBADIPDST -m set --match-set crowdsec6-blacklists dst -g $CHAINMAINOUTINTERLOGBADIPDSTWC" "" &

	# On configure les ouvertures de ports + redirection des ports
	# insert_rules_list_redirections "-AI NAT" "-AI FILTER" "-m ipv4" "-m ipv6" "-j FILTER" "tcp/udp" ARRAY
	# insert_rules_list_dnat "-AI" "-m ipv4" "-m ipv6" "tcp/udp" ARRAY
	# insert_rules_list_docker "-AI" "-m ipv4" "-m ipv6" "tcp/udp" ARRAY
	# TCP
	insert_rules_list_ports "-t filter" "-A $CHAINOPENLOCALPORTTCP" "" "" "-j ACCEPT" "tcp" "${localOpenPortsTCP[@]}" && \
		insert_rules "-t nat -A ${CHAINOPENLOCALPORTTCP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINOPENLOCALPORTTCP}-logs" && \
		insert_rules_list_redirections "-A $CHAINOPENLOCALPORTTCP" "-A $CHAINOPENLOCALPORTTCP" "" "" "-j ACCEPT" "tcp" "${localRedirectPortTCP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENLOCALPORTTCP" "" "" "tcp" "${localDnatPortTCP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENLOCALPORTTCP" "" "" "tcp" "${localDockerTCP[@]}" && \
		insert_rules_list_ports "-t filter" "-A $CHAINOPENLOCALPORTTCP" "" "" "-j ACCEPT" "tcp" "${openPortTCP[@]}" && \
		insert_rules_list_redirections "-A $CHAINOPENLOCALPORTTCP" "-A $CHAINOPENLOCALPORTTCP" "" "" "-j ACCEPT" "tcp" "${redirectPortTCP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENLOCALPORTTCP" "" "" "tcp" "${dnatPortTCP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENLOCALPORTTCP" "" "" "tcp" "${openDockerTCP[@]}" && \
		insert_rules_list_ports "-t filter" "-A $CHAINOPENLOCALPORTTCP" "" "" "-j ACCEPT" "tcp" "${WWopenPortTCP[@]}" && \
		insert_rules_list_redirections "-A $CHAINOPENLOCALPORTTCP" "-A $CHAINOPENLOCALPORTTCP" "" "" "-j ACCEPT" "tcp" "${WWredirectPortTCP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENLOCALPORTTCP" "" "" "tcp" "${WWdnatPortTCP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENLOCALPORTTCP" "" "" "tcp" "${WWDockerTCP[@]}" && \
		insert_rules_quietly "-t nat -A $CHAINOPENLOCALPORTTCP -j DOCKER" && \
		insert_rules "-A $CHAINOPENLOCALPORTTCP -j $CHAINPORTSENTRYOPENTCP" && \
		insert_rules "-A $CHAINOPENLOCALPORTTCP -j $CHAINDROPLOG" &
	
	insert_rules_list_ports "-t filter" "-A $CHAINOPENCRPORTTCP" "" "" "-j ACCEPT" "tcp" "${openPortTCP[@]}" && \
		insert_rules "-t nat -A ${CHAINOPENCRPORTTCP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINOPENCRPORTTCP}-logs" && \
		insert_rules_list_redirections "-A $CHAINOPENCRPORTTCP" "-A $CHAINOPENCRPORTTCP" "" "" "-j ACCEPT" "tcp" "${redirectPortTCP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENCRPORTTCP" "" "" "tcp" "${dnatPortTCP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENCRPORTTCP" "" "" "tcp" "${openDockerTCP[@]}" && \
		insert_rules_list_ports "-t filter" "-A $CHAINOPENCRPORTTCP" "" "" "-j ACCEPT" "tcp" "${WWopenPortTCP[@]}" && \
		insert_rules_list_redirections "-A $CHAINOPENCRPORTTCP" "-A $CHAINOPENCRPORTTCP" "" "" "-j ACCEPT" "tcp" "${WWredirectPortTCP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENCRPORTTCP" "" "" "tcp" "${WWdnatPortTCP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENCRPORTTCP" "" "" "tcp" "${WWDockerTCP[@]}" && \
		insert_rules_quietly "-t nat -A $CHAINOPENCRPORTTCP -j DOCKER" && \
		insert_rules "-A $CHAINOPENCRPORTTCP -j $CHAINPORTSENTRYOPENTCP" && \
		insert_rules "-A $CHAINOPENCRPORTTCP -j $CHAINDROPLOG" &

	# On met en place les autorisations pour les interfaces de l'exterieur. J'ai aussi mon ouverture de PLEX (A desactiver au besoin) (A ameliorer au besoin avec une fonction... Sauf qu'il va finir en container soon)
	# Open plex ports https://s3-eu-west-1.amazonaws.com/plex-sidekiq-servers-list/sidekiqIPs.txt
	insert_rules_list_ports "-t filter" "-A $CHAINOPENWWPORTTCP" "" "" "-j ACCEPT" "tcp" "${WWopenPortTCP[@]}" && \
		insert_rules "-t nat -A ${CHAINOPENWWPORTTCP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINOPENWWPORTTCP}-logs" && \
		insert_rules_list_redirections "-A $CHAINOPENWWPORTTCP" "-A $CHAINOPENWWPORTTCP" "" "" "-j ACCEPT" "tcp" "${WWredirectPortTCP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENWWPORTTCP" "" "" "tcp" "${WWdnatPortTCP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENWWPORTTCP" "" "" "tcp" "${WWDockerTCP[@]}" && \
		insert_rules_quietly "-t nat -A $CHAINOPENWWPORTTCP -j DOCKER" && \
		insert_rules "-A $CHAINOPENWWPORTTCP -j $CHAINPORTSENTRYOPENTCP" && \
		insert_rules_with_test_ok_ipv4 "-A $CHAINOPENWWPORTTCP -p tcp --dport 32400 -m set --match-set $IPSPLEXIPS src -j ACCEPT" "" && \
		insert_rules_with_test_ok_ipv6 "-A $CHAINOPENWWPORTTCP -p tcp --dport 32400 -m set --match-set ${IPSPLEXIPS}6 src -j ACCEPT" "" && \
		insert_rules_with_test_ok_ipv4 "-t nat -A ${CHAINOPENWWPORTTCP}-logs -p tcp --dport 34212 -m set --match-set $IPSPLEXIPS src -g ${CHAINPATLOG}" "" && \
		insert_rules_with_test_ok_ipv4 "-t nat -A $CHAINOPENWWPORTTCP -p tcp --dport 34212 -m set --match-set $IPSPLEXIPS src -j REDIRECT --to-port 32400" "" && \
		insert_rules_with_test_ok_ipv6 "-t nat -A ${CHAINOPENWWPORTTCP}-logs -p tcp --dport 34212 -m set --match-set ${IPSPLEXIPS}6 src -g ${CHAINPATLOG}" "" && \
		insert_rules_with_test_ok_ipv6 "-t nat -A $CHAINOPENWWPORTTCP -p tcp --dport 34212 -m set --match-set ${IPSPLEXIPS}6 src -j REDIRECT --to-port 32400" "" && \
		insert_rules "-A $CHAINOPENWWPORTTCP -j $CHAINDROPLOG" &

	# On oublie pas de Forward les redirections
	insert_rules_list_dnat_forward "tcp" "${IPAutorDnatPortTCP[@]}" && \
		insert_rules_list_docker_forward "tcp" "${IPAutorDockerTCP[@]}" && \
		insert_rules_list_dnat_forward "tcp" "${internalDnatPortTCP[@]}" && \
		insert_rules_list_docker_forward "tcp" "${internalDockerTCP[@]}" && \
		insert_rules_list_dnat_forward "tcp" "${localDnatPortTCP[@]}" && \
		insert_rules_list_docker_forward "tcp" "${localDockerTCP[@]}" && \
		insert_rules_list_dnat_forward "tcp" "${dnatPortTCP[@]}" && \
		insert_rules_list_docker_forward "tcp" "${openDockerTCP[@]}" && \
		insert_rules_list_dnat_forward "tcp" "${WWdnatPortTCP[@]}" 
		insert_rules_list_docker_forward "tcp" "${WWDockerTCP[@]}" & pidsToWaitForLinkFowardRules+=($!)

	# UDP
	insert_rules_list_ports "-t filter" "-A $CHAINOPENLOCALPORTUDP" "" "" "-j ACCEPT" "udp" "${localOpenPortsUDP[@]}" && \
		insert_rules "-t nat -A ${CHAINOPENLOCALPORTUDP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINOPENLOCALPORTUDP}-logs" && \
		insert_rules_list_redirections "-A $CHAINOPENLOCALPORTUDP" "-A $CHAINOPENLOCALPORTUDP" "" "" "-j ACCEPT" "udp" "${localRedirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENLOCALPORTUDP" "" "" "udp" "${localDnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENLOCALPORTUDP" "" "" "udp" "${localDockerUDP[@]}" && \
		insert_rules_list_ports "-t filter" "-A $CHAINOPENLOCALPORTUDP" "" "" "-j ACCEPT" "udp" "${openPortUDP[@]}" && \
		insert_rules_list_redirections "-A $CHAINOPENLOCALPORTUDP" "-A $CHAINOPENLOCALPORTUDP" "" "" "-j ACCEPT" "udp" "${redirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENLOCALPORTUDP" "" "" "udp" "${dnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENLOCALPORTUDP" "" "" "udp" "${openDockerUDP[@]}" && \
		insert_rules_list_ports "-t filter" "-A $CHAINOPENLOCALPORTUDP" "" "" "-j ACCEPT" "udp" "${WWopenPortUDP[@]}" && \
		insert_rules_list_redirections "-A $CHAINOPENLOCALPORTUDP" "-A $CHAINOPENLOCALPORTUDP" "" "" "-j ACCEPT" "udp" "${WWredirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENLOCALPORTUDP" "" "" "udp" "${WWdnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENLOCALPORTUDP" "" "" "udp" "${WWDockerUDP[@]}" && \
		insert_rules_quietly "-t nat -A $CHAINOPENLOCALPORTUDP -j DOCKER" && \
		insert_rules "-A $CHAINOPENLOCALPORTUDP -j $CHAINPORTSENTRYOPENUDP" && \
		insert_rules "-A $CHAINOPENLOCALPORTUDP -j $CHAINDROPLOG" &
	
	insert_rules_list_ports "-t filter" "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "-j ACCEPT" "udp" "${localOpenPortsUDP[@]}" && \
		insert_rules "-t nat -A ${CHAINOPENLOCALPORTUDPDHCP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINOPENLOCALPORTUDPDHCP}-logs" && \
		insert_rules_list_redirections "-A $CHAINOPENLOCALPORTUDPDHCP" "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "-j ACCEPT" "udp" "${localRedirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "udp" "${localDnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "udp" "${localDockerUDP[@]}" && \
		insert_rules_list_ports "-t filter" "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "-j ACCEPT" "udp" "${openPortUDP[@]}" && \
		insert_rules_list_redirections "-A $CHAINOPENLOCALPORTUDPDHCP" "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "-j ACCEPT" "udp" "${redirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "udp" "${dnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "udp" "${openDockerUDP[@]}" && \
		insert_rules_list_ports "-t filter" "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "-j ACCEPT" "udp" "${WWopenPortUDP[@]}" && \
		insert_rules_list_redirections "-A $CHAINOPENLOCALPORTUDPDHCP" "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "-j ACCEPT" "udp" "${WWredirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "udp" "${WWdnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENLOCALPORTUDPDHCP" "" "" "udp" "${WWDockerUDP[@]}" && \
		insert_rules_quietly "-t nat -A $CHAINOPENLOCALPORTUDPDHCP -j DOCKER" && \
		insert_rules "-A $CHAINOPENLOCALPORTUDPDHCP -j $CHAINPORTSENTRYOPENUDP" && \
		$IPT -A $CHAINOPENLOCALPORTUDPDHCP -p udp --sport 68 -m addrtype --dst-type local --dport 67 -j ACCEPT && \
		insert_rules "-A $CHAINOPENLOCALPORTUDPDHCP -j $CHAINDROPLOG" &
		
	insert_rules_list_ports "-t filter" "-A $CHAINOPENCRPORTUDP" "" "" "-j ACCEPT" "udp" "${openPortUDP[@]}" && \
		insert_rules "-t nat -A ${CHAINOPENCRPORTUDP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINOPENCRPORTUDP}-logs" && \
		insert_rules_list_redirections "-A $CHAINOPENCRPORTUDP" "-A $CHAINOPENCRPORTUDP" "" "" "-j ACCEPT" "udp" "${redirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENCRPORTUDP" "" "" "udp" "${dnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENCRPORTUDP" "" "" "udp" "${openDockerUDP[@]}" && \
		insert_rules_list_ports "-t filter" "-A $CHAINOPENCRPORTUDP" "" "" "-j ACCEPT" "udp" "${WWopenPortUDP[@]}" && \
		insert_rules_list_redirections "-A $CHAINOPENCRPORTUDP" "-A $CHAINOPENCRPORTUDP" "" "" "-j ACCEPT" "udp" "${WWredirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENCRPORTUDP" "" "" "udp" "${WWdnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENCRPORTUDP" "" "" "udp" "${WWDockerUDP[@]}" && \
		insert_rules_quietly "-t nat -A $CHAINOPENCRPORTUDP -j DOCKER" && \
		insert_rules "-A $CHAINOPENCRPORTUDP -j $CHAINPORTSENTRYOPENUDP" && \
		insert_rules "-A $CHAINOPENCRPORTUDP -j $CHAINDROPLOG" &
		
	insert_rules_list_ports "-t filter" "-A $CHAINOPENWWPORTUDP" "" "" "-j ACCEPT" "udp" "${WWopenPortUDP[@]}" && \
		insert_rules "-t nat -A ${CHAINOPENWWPORTUDP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINOPENWWPORTUDP}-logs" && \
		insert_rules_list_redirections "-A $CHAINOPENWWPORTUDP" "-A $CHAINOPENWWPORTUDP" "" "" "-j ACCEPT" "udp" "${WWredirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINOPENWWPORTUDP" "" "" "udp" "${WWdnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINOPENWWPORTUDP" "" "" "udp" "${WWDockerUDP[@]}" && \
		insert_rules_quietly "-t nat -A $CHAINOPENWWPORTUDP -j DOCKER" && \
		insert_rules "-A $CHAINOPENWWPORTUDP -j $CHAINPORTSENTRYOPENUDP" && \
		insert_rules "-A $CHAINOPENWWPORTUDP -j $CHAINDROPLOG" &
	
	# On oublie pas de Forward les redirections
	insert_rules_list_dnat_forward "udp" "${IPAutorDnatPortUDP[@]}" && \
		insert_rules_list_docker_forward "udp" "${IPAutorDockerUDP[@]}" && \
		insert_rules_list_dnat_forward "udp" "${internalDnatPortUDP[@]}" && \
		insert_rules_list_docker_forward "udp" "${internalDockerUDP[@]}" && \
		insert_rules_list_dnat_forward "udp" "${localDnatPortUDP[@]}" && \
		insert_rules_list_docker_forward "udp" "${localDockerUDP[@]}" && \
		insert_rules_list_dnat_forward "udp" "${dnatPortUDP[@]}" && \
		insert_rules_list_docker_forward "udp" "${openDockerUDP[@]}" && \
		insert_rules_list_dnat_forward "udp" "${WWdnatPortUDP[@]}" && \
		insert_rules_list_docker_forward "udp" "${WWDockerUDP[@]}" & pidsToWaitForLinkFowardRules+=($!)
	
	# INSERT RULES INTERNAL interfaces
	insert_rules_list_ports "-t filter" "-A $CHAINMAININTINTERTCP" "" "" "-j ACCEPT" "tcp" "${internalOpenPortsTCP[@]}" && \
		insert_rules "-t nat -A ${CHAINMAININTINTERTCP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINMAININTINTERTCP}-logs" && \
		insert_rules_list_redirections "-A $CHAINMAININTINTERTCP" "-A $CHAINMAININTINTERTCP" "" "" "-j ACCEPT" "tcp" "${internalRedirectPortTCP[@]}" && \
		insert_rules_list_dnat "-A $CHAINMAININTINTERTCP" "" "" "tcp" "${internalDnatPortTCP[@]}" && \
		insert_rules_list_docker "-A $CHAINMAININTINTERTCP" "" "" "tcp" "${internalDockerTCP[@]}" && \
		insert_rules "-A $CHAINMAININTINTERTCP -j $CHAINOPENLOCALPORTTCP" && \
		insert_rules "-t nat -A $CHAINMAININTINTERTCP -j $CHAINOPENLOCALPORTTCP" &
	insert_rules_list_ports "-t filter" "-A $CHAINMAININTINTERUDP" "" "" "-j ACCEPT" "udp" "${internalOpenPortsUDP[@]}" && \
		insert_rules "-t nat -A ${CHAINMAININTINTERUDP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINMAININTINTERUDP}-logs" && \
		insert_rules_list_redirections "-A $CHAINMAININTINTERUDP" "-A $CHAINMAININTINTERUDP" "" "" "-j ACCEPT" "udp" "${internalRedirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINMAININTINTERUDP" "" "" "udp" "${internalDnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINMAININTINTERUDP" "" "" "udp" "${internalDockerUDP[@]}" && \
		insert_rules "-A $CHAINMAININTINTERUDP -j $CHAINOPENLOCALPORTUDP" && \
		insert_rules "-t nat -A $CHAINMAININTINTERUDP -j $CHAINOPENLOCALPORTUDP" &
	insert_rules_list_ports "-t filter" "-A $CHAINMAININTINTERUDPDHCP" "" "" "-j ACCEPT" "udp" "${internalOpenPortsUDP[@]}" && \
		insert_rules "-t nat -A ${CHAINMAININTINTERUDPDHCP} -m state ! --state ESTABLISHED,RELATED -j ${CHAINMAININTINTERUDPDHCP}-logs" && \
		insert_rules_list_redirections "-A $CHAINMAININTINTERUDPDHCP" "-A $CHAINMAININTINTERUDPDHCP" "" "" "-j ACCEPT" "udp" "${internalRedirectPortUDP[@]}" && \
		insert_rules_list_dnat "-A $CHAINMAININTINTERUDPDHCP" "" "" "udp" "${internalDnatPortUDP[@]}" && \
		insert_rules_list_docker "-A $CHAINMAININTINTERUDPDHCP" "" "" "udp" "${internalDockerUDP[@]}" && \
		insert_rules "-A $CHAINMAININTINTERUDPDHCP -j $CHAINOPENLOCALPORTUDPDHCP" && \
		insert_rules "-t nat -A $CHAINMAININTINTERUDPDHCP -j $CHAINOPENLOCALPORTUDPDHCP" &

	$IPT -A $CHAINMAININTINTERICMP -m state --state ESTABLISHED,RELATED -j ACCEPT && \
		insert_rules_with_test_ok_ipv4 "-A $CHAINMAININTINTERICMP -m set --match-set $IPSLISTBADIP src -j DROP" "" && \
		$IPT -A $CHAINMAININTINTERICMP -j ACCEPT &
	$IPT6 -A $CHAINMAININTINTERICMP -m state --state ESTABLISHED,RELATED -j ACCEPT && \
		insert_rules_with_test_ok_ipv6 "-A $CHAINMAININTINTERICMP -p icmpv6 --icmpv6-type echo-request -m set --match-set ${IPSLISTBADIP}6 src -j DROP" "" && \
		$IPT6 -A $CHAINMAININTINTERICMP -p ipv6-icmp -j ACCEPT &
	
	# Create subs rules outside network
	$IPT -A $CHAINMAINOUTINTERCR -p icmp -g $CHAINMAINOUTINTERICMP && \
		$IPT6 -A $CHAINMAINOUTINTERCR -p ipv6-icmp -g $CHAINMAINOUTINTERICMP && \
		insert_rules "-A $CHAINMAINOUTINTERCR -j $CHAINMAINOUTINTERDROPBADIPSRC" && \
		insert_rules "-A $CHAINMAINOUTINTERCR -p tcp -g $CHAINOPENCRPORTTCP" && \
		insert_rules "-A $CHAINMAINOUTINTERCR -p udp -g $CHAINOPENCRPORTUDP" &
	
	insert_rules_with_test_ok_ipv4 "-t nat -A $CHAINMAINOUTINTERCR -m set --match-set $IPSLISTBADIP src -j RETURN" "" && \
		insert_rules_with_test_ok_ipv4 "-t nat -A $CHAINMAINOUTINTERCR -m set --match-set crowdsec-blacklists src -j RETURN" "" && \
		insert_rules_with_test_ok_ipv6 "-t nat -A $CHAINMAINOUTINTERCR -m set --match-set ${IPSLISTBADIP}6 src -j RETURN" "" && \
		insert_rules_with_test_ok_ipv6 "-t nat -A $CHAINMAINOUTINTERCR -m set --match-set crowdsec6-blacklists src -j RETURN" "" && \
		insert_rules "-t nat -A $CHAINMAINOUTINTERCR -p tcp -g $CHAINOPENCRPORTTCP" && \
		insert_rules "-t nat -A $CHAINMAINOUTINTERCR -p udp -g $CHAINOPENCRPORTUDP" &
		
	$IPT -A $CHAINMAINOUTINTERWW -p icmp -g $CHAINMAINOUTINTERICMP && \
		$IPT6 -A $CHAINMAINOUTINTERWW -p ipv6-icmp -g $CHAINMAINOUTINTERICMP && \
		insert_rules "-A $CHAINMAINOUTINTERWW -j $CHAINMAINOUTINTERDROPBADIPSRC" && \
		insert_rules "-A $CHAINMAINOUTINTERWW -p tcp -g $CHAINOPENWWPORTTCP" && \
		insert_rules "-A $CHAINMAINOUTINTERWW -p udp -g $CHAINOPENWWPORTUDP" &
	
	insert_rules_with_test_ok_ipv4 "-t nat -A $CHAINMAINOUTINTERWW -m set --match-set $IPSLISTBADIP src -j RETURN" "" && \
		insert_rules_with_test_ok_ipv4 "-t nat -A $CHAINMAINOUTINTERWW -m set --match-set crowdsec-blacklists src -j RETURN" "" && \
		insert_rules_with_test_ok_ipv6 "-t nat -A $CHAINMAINOUTINTERWW -m set --match-set ${IPSLISTBADIP}6 src -j RETURN" "" && \
		insert_rules_with_test_ok_ipv6 "-t nat -A $CHAINMAINOUTINTERWW -m set --match-set crowdsec6-blacklists src -j RETURN" "" && \
		insert_rules "-t nat -A $CHAINMAINOUTINTERWW -p tcp -g $CHAINOPENWWPORTTCP" && \
		insert_rules "-t nat -A $CHAINMAINOUTINTERWW -p udp -g $CHAINOPENWWPORTUDP" &
	
	# On prepare les règles ICMP aussi
	# Mais tester le state serait inutile ?
	$IPT -A $CHAINMAINOUTINTERICMP -m state --state ESTABLISHED,RELATED -j ACCEPT && \
		insert_rules_with_test_ok_ipv4 "-A $CHAINMAINOUTINTERICMP -m geoip --src-cc $blockedCountry -j DROP" "" && \
		insert_rules_with_test_ok_ipv4 "-A $CHAINMAINOUTINTERICMP -m geoip --src-cc $blockedCountry2 -j DROP" "" && \
		$IPT -A $CHAINMAINOUTINTERICMP -j $CHAINMAINOUTINTERDROPBADIPSRC && \
		$IPT -A $CHAINMAINOUTINTERICMP -j ACCEPT &
	
	$IPT6 -A $CHAINMAINOUTINTERICMP -m state --state ESTABLISHED,RELATED -j ACCEPT && \
		insert_rules_with_test_ok_ipv6 "-A $CHAINMAINOUTINTERICMP -p icmpv6 --icmpv6-type echo-request -m geoip --src-cc $blockedCountry -j DROP" "" && \
		insert_rules_with_test_ok_ipv6 "-A $CHAINMAINOUTINTERICMP -p icmpv6 --icmpv6-type echo-request -m geoip --src-cc $blockedCountry2 -j DROP" "" && \
		$IPT6 -A $CHAINMAINOUTINTERICMP -p icmpv6 --icmpv6-type echo-request -j $CHAINMAINOUTINTERDROPBADIPSRC && \
		$IPT6 -A $CHAINMAINOUTINTERICMP -p ipv6-icmp -j ACCEPT &

	# On doit aussi le configurer pour les ip allow
	# On autorise nos IP mais il ne faut pas qu'elle puissent être ban par portsentry
	insert_rules "-A $CHAINIPALLOW -p tcp -j $CHAINPORTSENTRYCLOSETCP" && insert_rules "-A $CHAINIPALLOW -p udp -j $CHAINPORTSENTRYCLOSEUDP" && insert_rules "-A $CHAINIPALLOW -j ACCEPT" &
	insert_rules "-t nat -A $CHAINIPALLOW -p tcp -g $CHAINIPALLOWTCP" &
	insert_rules "-t nat -A $CHAINIPALLOW -p udp -g $CHAINIPALLOWUDP" &
	insert_rules_list_dnat "-A $CHAINIPALLOWTCP" "" "" "tcp" "${IPAutorDnatPortTCP[@]}" && insert_rules_list_docker "-A $CHAINIPALLOWTCP" "" "" "tcp" "${IPAutorDockerTCP[@]}" && insert_rules "-t nat -A $CHAINIPALLOWTCP -j $CHAINMAININTINTERTCP" &
	insert_rules_list_dnat "-A $CHAINIPALLOWUDP" "" "" "udp" "${IPAutorDnatPortUDP[@]}" && insert_rules_list_docker "-A $CHAINIPALLOWUDP" "" "" "udp" "${IPAutorDockerUDP[@]}" && insert_rules "-t nat -A $CHAINIPALLOWUDP -j $CHAINMAININTINTERUDPDHCP" &

	# On souhaite choisir quand ouvrir et fermer les ports de portsentry et son ultimate ban
	read -a portSentryTCP <<< `grep -m 1 "^TCP_PORTS" /etc/portsentry/portsentry.conf | sed 's/TCP_PORTS=//' | sed 's/"//g' | tr ',' ' '`
	read -a portSentryUDP <<< `grep -m 1 "^UDP_PORTS" /etc/portsentry/portsentry.conf | sed 's/UDP_PORTS=//' | sed 's/"//g' | tr ',' ' '`
	insert_rules_list_ports "-t filter" "-A $CHAINPORTSENTRYOPENTCP" "" "" "-j $CHAINPORTSENTRYLOG" "tcp" "${portSentryTCP[@]}" &
	insert_rules_list_ports "-t filter" "-A $CHAINPORTSENTRYCLOSETCP" "" "" "-j DROP" "tcp" "${portSentryTCP[@]}" &

	insert_rules_list_ports "-t filter" "-A $CHAINPORTSENTRYOPENUDP" "" "" "-j $CHAINPORTSENTRYLOG" "udp" "${portSentryUDP[@]}" &
	insert_rules_list_ports "-t filter" "-A $CHAINPORTSENTRYCLOSEUDP" "" "" "-j DROP" "udp" "${portSentryUDP[@]}" &

	#-j LOG --log-prefix [iptables-portsentry]: 
	insert_rules "-A $CHAINPORTSENTRYLOG -m state ! --state ESTABLISHED,RELATED -j NFLOG --nflog-threshold 3 --nflog-group 61" && \
		$IPT -A $CHAINPORTSENTRYLOG -j ACCEPT && \
		$IPT6 -A $CHAINPORTSENTRYLOG -j DROP &

	insert_rules "-A $CHAINDROPCAST -m addrtype --dst-type MULTICAST -j DROP" &
	insert_rules "-A $CHAINDROPCAST -m addrtype --src-type MULTICAST -j DROP" &
	insert_rules_quietly "-A $CHAINDROPCAST -m addrtype --dst-type BROADCAST -j DROP" &
	insert_rules_quietly "-A $CHAINDROPCAST -m addrtype --src-type BROADCAST -j DROP" &

	insert_rules "-A $CHAINDROPLOGSELECTOR -j $CHAINDROPCAST" && \
		insert_rules "-A $CHAINDROPLOGSELECTOR -j $CHAINDROPLOGWITHOUTSELECTOR" &

	#-j LOG --log-prefix [iptables-trash]: --log-level 7 --log-uid
	insert_rules "-A $CHAINDROPLOGWITHOUTSELECTOR -j NFLOG --nflog-threshold 10 --nflog-group 60" && \
		insert_rules "-A $CHAINDROPLOGWITHOUTSELECTOR -j DROP" &
	
	insert_rules "-A $CHAINDROPLOG -m state ! --state ESTABLISHED,RELATED -g $CHAINDROPLOGSELECTOR" && \
		insert_rules "-A $CHAINDROPLOG -j DROP" &
	
	# On configure le forward pour eviter de prendre trop de temps pour les VM
	insert_rules "-I FORWARD 1 -j $CHAINFORWARDTRAFIC" && insert_rules "-I FORWARD 1 -m state ! --state ESTABLISHED,RELATED -j $CHAINFORWARDFILTER" &
	insert_rules "-I $CHAINFORWARDTRAFIC 1 -j $CHAINMAINOUTINTERLOGBADIPDST" &
	insert_rules "-A $CHAINFORWARDFILTER -m addrtype --dst-type local -j $CHAINDROPLOGWITHOUTSELECTOR" && \
		insert_rules "-A $CHAINFORWARDFILTER -j $CHAINDROPCAST" && \
		insert_rules "-A $CHAINFORWARDFILTER -j $CHAINMAINOUTINTERDROPBADIPSRC" && \
		insert_rules_quietly "-A $CHAINFORWARDFILTER -j DOCKER-ISOLATION-STAGE-1" && \
		$IPT -A $CHAINFORWARDFILTER -m set --match-set ${IPSDOH} dst -g $CHAINDROPLOGWITHOUTSELECTOR && \
		$IPT6 -A $CHAINFORWARDFILTER -m set --match-set ${IPSDOH}6 dst -g $CHAINDROPLOGWITHOUTSELECTOR && \
		$IPT -A $CHAINFORWARDFILTER -o $mainInter -m set --match-set ${IPSLOCALS} dst -g $CHAINDROPLOGWITHOUTSELECTOR && \
		$IPT6 -A $CHAINFORWARDFILTER -o $mainInter -m set --match-set ${IPSLOCALS}6 dst -g $CHAINDROPLOGWITHOUTSELECTOR && \
		insert_rules "-A $CHAINFORWARDFILTER -p udp -g $CHAINFORWARDFILTERUDP" && \
		insert_rules "-A $CHAINFORWARDFILTER -p tcp -g $CHAINFORWARDFILTERTCP" && \
		$IPT -A $CHAINFORWARDFILTER -p icmp -g $CHAINFORWARDFILTERICMP && \
		$IPT6 -A $CHAINFORWARDFILTER -p ipv6-icmp -g $CHAINFORWARDFILTERICMP &
	
	# Il n'est pas utile de forward les traffic vers les ports dhcp
	insert_rules "-A $CHAINFORWARDFILTERUDP -p udp --dport 67 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	insert_rules "-A $CHAINFORWARDFILTERUDP -p udp --sport 68 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	insert_rules "-A $CHAINFORWARDFILTERUDP -p udp --dport 547 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	insert_rules "-A $CHAINFORWARDFILTERUDP -p udp --sport 546 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	# On souhaite flitrer les requetes DNS foward. Il serait bien pour notre propre protection.
	insert_rules "-A $CHAINFORWARDFILTERTCP -p tcp --dport 53 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	insert_rules "-A $CHAINFORWARDFILTERUDP -p udp --dport 53 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	insert_rules "-A $CHAINFORWARDFILTERTCP -p tcp --dport 853 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	insert_rules "-A $CHAINFORWARDFILTERUDP -p udp --dport 853 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	insert_rules "-A $CHAINFORWARDFILTERTCP -p tcp --dport 5353 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	insert_rules "-A $CHAINFORWARDFILTERUDP -p udp --dport 5353 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	insert_rules "-A $CHAINFORWARDFILTERTCP -p tcp --dport 9050 -g $CHAINDROPLOGWITHOUTSELECTOR" &
	$IPT -A $CHAINFORWARDFILTERICMP -p icmp --icmp-type address-mask-request -g $CHAINDROPLOGWITHOUTSELECTOR &
	$IPT -A $CHAINFORWARDFILTERICMP -p icmp --icmp-type timestamp-request -g $CHAINDROPLOGWITHOUTSELECTOR &
	$IPT -A $CHAINFORWARDFILTERICMP -p icmp --icmp-type echo-request -g $CHAINDROPLOGWITHOUTSELECTOR &
	$IPT6 -A $CHAINFORWARDFILTERICMP -p ipv6-icmp --icmpv6-type echo-request -g $CHAINDROPLOGWITHOUTSELECTOR &
	$IPT6 -A $CHAINFORWARDFILTERICMP -p ipv6-icmp --icmpv6-type neighbour-advertisement -g $CHAINDROPLOGWITHOUTSELECTOR &
	$IPT6 -A $CHAINFORWARDFILTERICMP -p ipv6-icmp --icmpv6-type neighbour-solicitation -g $CHAINDROPLOGWITHOUTSELECTOR &
	$IPT6 -A $CHAINFORWARDFILTERICMP -p ipv6-icmp --icmpv6-type router-advertisement -g $CHAINDROPLOGWITHOUTSELECTOR &
	$IPT6 -A $CHAINFORWARDFILTERICMP -p ipv6-icmp --icmpv6-type router-solicitation -g $CHAINDROPLOGWITHOUTSELECTOR &

	# Nous souhaitons log le trafic sortant vers des IPs problématiques # -m state --state NEW
	insert_rules "-A $CHAINOUTTRAFIC -j $CHAINMAINOUTINTERLOGBADIPDST" && \
		$IPT -A $CHAINOUTTRAFIC -m set --match-set ${IPSDOH} dst -g $CHAINDROPLOGWITHOUTSELECTOR && \
		$IPT6 -A $CHAINOUTTRAFIC -m set --match-set ${IPSDOH}6 dst -g $CHAINDROPLOGWITHOUTSELECTOR && \
		insert_rules "-A $CHAINOUTTRAFIC -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT" && \
		insert_rules "-A $CHAINOUTTRAFIC -m conntrack --ctstate NEW,ESTABLISHED,RELATED -j ACCEPT" &

	# Le plus simple est de faire l'appel avec une selection de tout ce qui est commun sur les DHCP
	# "-p udp -s 0.0.0.0 --sport 68 --dport 67"
	# Après ce n'est que la formalité de la destination
	$IPT -A $CHAINOPENDHCP -p udp -d 255.255.255.255 -j ACCEPT &
	$IPT -A $CHAINOPENDHCP -p udp -m addrtype --dst-type local -j ACCEPT &
	
	declare -a pidsInt=()
	declare -gA interfaceDHCP=()
	wait "${pidsInp[@]}" "${pidsNat[@]}"
	for INTER in "${internInterfaceHaveAccessAsLocal[@]}"; do
		insert_rules_accept_trafic_local_interface $INTER & pidsInt+=($!)
		if [ -v interfaceWithDHCP["$INTER"] ] && [ "${interfaceWithDHCP[$INTER]}" -eq 1 ]; then
			IFS=';' read -r -a INTERC <<< $INTER
			interfaceDHCP[${INTERC[0]}]=1
		fi
	done

	for INTER in "${INTEROut[@]}"; do
		insert_rules_accept_trafic_local_out_interface $INTER & pidsInt+=($!)
		if [ -v interfaceWithDHCP["$INTER"] ] && [ "${interfaceWithDHCP[$INTER]}" -eq 1 ]; then
			IFS=';' read -r -a INTERC <<< $INTER
			interfaceDHCP[${INTERC[0]}]=1
		fi
	done

	local dnatPORT
	local dnatPORTC
	declare -A interfaceOK=()
	declare -A interfaceOKForward=()
	declare -a pidsIntm=()
	wait "${pidsInt[@]}"
	for INTER in "${INTEROut[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		if [ ! -v interfaceOK[${INTERC[0]}] ]; then
			interfaceOK[${INTERC[0]}]=0
			insert_rules_accept_trafic_out_interface ${INTERC[0]} && insert_rules_end_interfaces ${INTERC[0]} & pidsIntm+=($!)
		fi
	done
	
	for INTER in "${internInterfaceHaveAccessAsLocal[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		if [ ! -v interfaceOK[${INTERC[0]}] ]; then
			interfaceOK[${INTERC[0]}]=0
			insert_rules_end_interfaces ${INTERC[0]} & pidsIntm+=($!)
		fi
	done
	
	wait "${pidsToWaitForLinkFowardRules[@]}"
	for INTER in "${interfaceToGoOutSide[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		if [ ! -v interfaceOKForward[${INTERC[0]}] ]; then
			interfaceOKForward[${INTERC[0]}]=0
			insert_rules "-A ${CHAINFORWARDTRAFIC}-from -i ${INTERC[0]} -g ${CHAINFORWARDTRAFIC}-from-${INTERC[0]}" &
			insert_rules "-A ${CHAINFORWARDTRAFIC}-to -o ${INTERC[0]} -g ${CHAINFORWARDTRAFIC}-to-${INTERC[0]}" &
		fi
	done
	
	for dnatPORT in ${IPAutorDnatPortTCP[@]} ${IPAutorDnatPortUDP[@]} ${internalDnatPortTCP[@]} ${internalDnatPortUDP[@]} ${localDnatPortTCP[@]} ${localDnatPortUDP[@]} ${dnatPortTCP[@]} ${dnatPortUDP[@]} ${WWdnatPortTCP[@]} ${WWdnatPortUDP[@]} ${IPAutorDockerTCP[@]} ${IPAutorDockerUDP[@]} ${internalDockerTCP[@]} ${internalDockerUDP[@]} ${localDockerTCP[@]} ${localDockerUDP[@]} ${openDockerTCP[@]} ${openDockerUDP[@]} ${WWDockerTCP[@]} ${WWDockerUDP[@]}; do
		IFS=',' read -r -a dnatPORTC <<< $dnatPORT
		if [ ! -v interfaceOKForward[${dnatPORTC[1]}] ]; then
			interfaceOKForward[${dnatPORTC[1]}]=0
			insert_rules "-A ${CHAINFORWARDTRAFIC}-from -i ${dnatPORTC[1]} -g ${CHAINFORWARDTRAFIC}-from-${dnatPORTC[1]}" &
			insert_rules "-A ${CHAINFORWARDTRAFIC}-to -o ${dnatPORTC[1]} -g ${CHAINFORWARDTRAFIC}-to-${dnatPORTC[1]}" &
		fi
	done
	
	declare -A interfaceOKForwardIsolated=()
	wait "${pidsIntm[@]}"
	# En toute fin, on ajoute le liens vers le docker. Nous pouvons ainsi valider que nos connexions sont bonnes.
	insert_rules "-A INPUT -j $CHAINDROPLOG" &
	insert_rules_quietly "-t nat -A $CHAINPATMAIN -j DOCKER" &
	/bin/bash /etc/firewall/firewall.rules.special
	
	for INTER in "${interfaceToGoOutSide[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		if [ ! -v interfaceOKForwardIsolated[${INTERC[0]}] ]; then
			interfaceOKForwardIsolated[${INTERC[0]}]=0
			# On souhaite que ces interfaces qui ont un acces externe puissent être isolées les une des autres par default
			insert_rules "-A ${CHAINFORWARDTRAFIC}-to-${INTERC[0]} -j DROP" &
		fi
	done
	
	for dnatPORT in ${IPAutorDnatPortTCP[@]} ${IPAutorDnatPortUDP[@]} ${internalDnatPortTCP[@]} ${internalDnatPortUDP[@]} ${localDnatPortTCP[@]} ${localDnatPortUDP[@]} ${dnatPortTCP[@]} ${dnatPortUDP[@]} ${WWdnatPortTCP[@]} ${WWdnatPortUDP[@]}; do
		IFS=',' read -r -a dnatPORTC <<< $dnatPORT
		if [ ! -v interfaceOKForwardIsolated[${dnatPORTC[1]}] ]; then
			interfaceOKForwardIsolated[${dnatPORTC[1]}]=0
			# On souhaite que ces interfaces qui ont un acces externe puissent être isolées les une des autres par default
			insert_rules "-A ${CHAINFORWARDTRAFIC}-to-${dnatPORTC[1]} -j DROP" &
		fi
	done

	# Il faudrait rajouter des reseaux isolés. Surtout de docker.
	wait

return 0
}

insert_rules() # You can use it to remove rules too
{
	local cmd_args=$1 # -t nat -I ? -m ? -j ?
	local pid1
	local pid2
	$IPT $cmd_args & pid1=$!
	$IPT6 $cmd_args & pid2=$!
	wait $pid1 || echo "Bugged v4 $cmd_args"
	wait $pid2 || echo "Bugged v6 $cmd_args"
	return 0
}

insert_rules_quietly() # You can use it to remove rules too
{
	local cmd_args=$1 # -t nat -I ? -m ? -j ?
	local pid1
	local pid2
	$IPT $cmd_args 2> /dev/null & pid1=$!
	$IPT6 $cmd_args 2> /dev/null & pid2=$!
	wait $pid1
	wait $pid2
	return 0
}

#
# Function that remove chain
#
remove_chain()
{
	local table=$1
	local chain=$2
	local pid1
	local pid2
	$IPT -t $table -F $chain 2> /dev/null && $IPT -t $table -X $chain 2> /dev/null & pid1=$!
	$IPT6 -t $table -F $chain 2> /dev/null && $IPT6 -t $table -X $chain 2> /dev/null & pid2=$!
	wait $pid1
	wait $pid2
	return 0
}

remove_chain_list()
{
	local table=$1
	shift
	local chains=("$@")
	for chain in "${chains[@]}"; do
		remove_chain $table $chain
	done
}

remove_chain_interface_network()
{
	declare -a pids=()
	local INTER=$1
	local INTERC
	IFS=';' read -r -a INTERC <<< $INTER
	remove_chain "filter" "${CHAINMAININTER}-${INTERC[0]}"
	$IPT -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null && $IPT -X ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null & pids+=($!)
	$IPT6 -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null && $IPT6 -X ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null & pids+=($!)
	remove_chain "nat" "${CHAINMAININTER}-${INTERC[0]}"
	$IPT -t nat -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null && $IPT -t nat -X ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null & pids+=($!)
	$IPT6 -t nat -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null && $IPT6 -t nat -X ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null & pids+=($!)
	wait "${pids[@]}"
}

#
# Function that reset the firewall rules
#
delete_rules()
{
	declare -a pids=()
	insert_rules "-A INPUT -j DROP" && insert_rules "-P INPUT ACCEPT" && \
		insert_rules "-F INPUT" && insert_rules "-A INPUT -i lo -j ACCEPT" && \
		insert_rules "-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT" && \
		insert_rules "-P INPUT DROP" & pids+=($!)
	insert_rules "-P FORWARD DROP" & pids+=($!)
	insert_rules "-t raw -F PREROUTING" & pids+=($!)
	insert_rules "-t nat -F PREROUTING" & pids+=($!)
	insert_rules "-t nat -D POSTROUTING -j $CHAINPOSTROUTINGNAT" & pids+=($!)
	insert_rules "-D FORWARD -j $CHAINFORWARDTRAFIC" & pids+=($!)
	insert_rules_quietly "-D FORWARD -m state ! --state ESTABLISHED,RELATED -j $CHAINFORWARDFILTER" & pids+=($!)

	declare -a pidsb=()
	
	insert_rules "-t nat -D POSTROUTING -o $mainInter -j MASQUERADE" & pidsb+=($!)
	insert_rules "-t nat -D POSTROUTING -m addrtype --dst-type MULTICAST -j RETURN" & pidsb+=($!)
	insert_rules "-t nat -D POSTROUTING -m addrtype --dst-type BROADCAST -j RETURN" & pidsb+=($!)
	insert_rules "-t nat -D POSTROUTING -m addrtype --src-type MULTICAST -j RETURN" & pidsb+=($!)
	insert_rules "-t nat -D POSTROUTING -m addrtype --src-type BROADCAST -j RETURN" & pidsb+=($!)
	insert_rules "-t nat -D POSTROUTING -m addrtype --dst-type local -j RETURN" & pidsb+=($!)
	insert_rules "-t nat -D POSTROUTING -m addrtype --src-type local -j RETURN" & pidsb+=($!)
	insert_rules "-t nat -D POSTROUTING -s 224.0.0.0/24 -j RETURN" & pidsb+=($!)
	insert_rules "-t nat -D POSTROUTING -s 255.255.255.255 -j RETURN" & pidsb+=($!)

	#$IPT -F FORWARD
	insert_rules "-F OUTPUT" & pidsb+=($!)
	
	local pidS
	local INTER
	local INTERC
	wait "${pids[@]}"
	remove_chain_list "filter" $SPECIALCHAINLIST & pidS=$!
	remove_chain_list "nat" $NATCHAINLIST & pidsb+=($!)
	remove_chain "raw" $CHAINICMPTRAFIC & pidsb+=($!)
	
	for INTER in "${internInterfaceHaveAccessAsLocal[@]}"; do
		remove_chain_interface_network "$INTER" & pidsb+=($!)
	done

	for INTER in "${INTEROut[@]}"; do
		remove_chain_interface_network "$INTER" & pidsb+=($!)
	done
	
	wait $pidS
	for INTER in "${interfaceToGoOutSide[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		remove_chain "filter" "${CHAINFORWARDTRAFIC}-from-${INTERC[0]}" & pidsb+=($!)
		remove_chain "filter" "${CHAINFORWARDTRAFIC}-to-${INTERC[0]}" & pidsb+=($!)
	done
	
	local dnatPORT
	local dnatPORTC
	for dnatPORT in ${IPAutorDnatPortTCP[@]} ${IPAutorDnatPortUDP[@]} ${internalDnatPortTCP[@]} ${internalDnatPortUDP[@]} ${localDnatPortTCP[@]} ${localDnatPortUDP[@]} ${dnatPortTCP[@]} ${dnatPortUDP[@]} ${WWdnatPortTCP[@]} ${WWdnatPortUDP[@]} ${IPAutorDockerTCP[@]} ${IPAutorDockerUDP[@]} ${internalDockerTCP[@]} ${internalDockerUDP[@]} ${localDockerTCP[@]} ${localDockerUDP[@]} ${openDockerTCP[@]} ${openDockerUDP[@]} ${WWDockerTCP[@]} ${WWDockerUDP[@]}; do
		IFS=',' read -r -a dnatPORTC <<< $dnatPORT
		remove_chain "filter" "${CHAINFORWARDTRAFIC}-from-${dnatPORTC[1]}" & pidsb+=($!)
		remove_chain "filter" "${CHAINFORWARDTRAFIC}-to-${dnatPORTC[1]}" & pidsb+=($!)
	done

	wait "${pidsb[@]}"
	return 0
}

flush_rules()
{
	declare -a pids=()
	insert_rules "-A INPUT -j DROP" && insert_rules "-P INPUT ACCEPT" && \
		insert_rules "-F INPUT" && insert_rules "-A INPUT -i lo -j ACCEPT" && \
		insert_rules "-A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT" && \
		insert_rules "-P INPUT DROP" & pids+=($!)
	insert_rules "-P FORWARD DROP" & pids+=($!)
	insert_rules "-t raw -F PREROUTING" & pids+=($!)
	insert_rules "-t nat -F PREROUTING" & pids+=($!)
	# insert_rules "-t nat -D POSTROUTING -j $CHAINPOSTROUTINGNAT" & pids+=($!)
	insert_rules "-D FORWARD -j $CHAINFORWARDTRAFIC" & pids+=($!)
	insert_rules_quietly "-D FORWARD -m state ! --state ESTABLISHED,RELATED -j $CHAINFORWARDFILTER" & pids+=($!)
	
	insert_rules_quietly "-t nat -D POSTROUTING -o $mainInter -j MASQUERADE" & pids+=($!)
	insert_rules_quietly "-t nat -D POSTROUTING -m addrtype --dst-type MULTICAST -j RETURN" & pids+=($!)
	insert_rules_quietly "-t nat -D POSTROUTING -m addrtype --dst-type BROADCAST -j RETURN" & pids+=($!)
	insert_rules_quietly "-t nat -D POSTROUTING -m addrtype --src-type MULTICAST -j RETURN" & pids+=($!)
	insert_rules_quietly "-t nat -D POSTROUTING -m addrtype --src-type BROADCAST -j RETURN" & pids+=($!)
	insert_rules_quietly "-t nat -D POSTROUTING -m addrtype --dst-type local -j RETURN" & pids+=($!)
	insert_rules_quietly "-t nat -D POSTROUTING -m addrtype --src-type local -j RETURN" & pids+=($!)
	insert_rules_quietly "-t nat -D POSTROUTING -d 224.0.0.0/24 -j RETURN" & pids+=($!)
	insert_rules_quietly "-t nat -D POSTROUTING -d 255.255.255.255 -j RETURN" & pids+=($!)
	insert_rules_quietly "-D FORWARD -j DOCKER-ISOLATION-STAGE-1" & pids+=($!)

	#$IPT -F FORWARD
	insert_rules "-F OUTPUT" & pids+=($!)
	
	insert_rules_quietly "-t raw -F $CHAINICMPTRAFIC" & pids+=($!)
	
	for chain in "${SPECIALCHAINLIST[@]}"; do
		insert_rules_quietly "-F $chain " & pids+=($!)
	done
	for chain in "${NATCHAINLIST[@]}"; do
		insert_rules_quietly "-t nat -F $chain" & pids+=($!)
	done
	
	local INTER
	local INTERC
	for INTER in "${internInterfaceHaveAccessAsLocal[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		insert_rules_quietly "-F ${CHAINMAININTER}-${INTERC[0]}" & pids+=($!)
		$IPT -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null & pids+=($!)
		$IPT6 -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null & pids+=($!)
		insert_rules_quietly "-t nat -F ${CHAINMAININTER}-${INTERC[0]}" & pids+=($!)
		$IPT -t nat -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null & pids+=($!)
		$IPT6 -t nat -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null & pids+=($!)
	done

	for INTER in "${INTEROut[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		insert_rules_quietly "-F ${CHAINMAININTER}-${INTERC[0]}" & pids+=($!)
		$IPT -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null & pids+=($!)
		$IPT6 -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null & pids+=($!)
		insert_rules_quietly "-t nat -F ${CHAINMAININTER}-${INTERC[0]}" & pids+=($!)
		$IPT -t nat -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null & pids+=($!)
		$IPT6 -t nat -F ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null & pids+=($!)
	done
	
	for INTER in "${interfaceToGoOutSide[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		insert_rules_quietly "-F ${CHAINFORWARDTRAFIC}-from-${INTERC[0]}" & pids+=($!)
		insert_rules_quietly "-F ${CHAINFORWARDTRAFIC}-to-${INTERC[0]}" & pids+=($!)
	done
	
	local dnatPORT
	local dnatPORTC
	for dnatPORT in ${IPAutorDnatPortTCP[@]} ${IPAutorDnatPortUDP[@]} ${internalDnatPortTCP[@]} ${internalDnatPortUDP[@]} ${localDnatPortTCP[@]} ${localDnatPortUDP[@]} ${dnatPortTCP[@]} ${dnatPortUDP[@]} ${WWdnatPortTCP[@]} ${WWdnatPortUDP[@]} ${IPAutorDockerTCP[@]} ${IPAutorDockerUDP[@]} ${internalDockerTCP[@]} ${internalDockerUDP[@]} ${localDockerTCP[@]} ${localDockerUDP[@]} ${openDockerTCP[@]} ${openDockerUDP[@]} ${WWDockerTCP[@]} ${WWDockerUDP[@]}; do
		IFS=',' read -r -a dnatPORTC <<< $dnatPORT
		insert_rules_quietly "-F ${CHAINFORWARDTRAFIC}-from-${dnatPORTC[1]}" & pids+=($!)
		insert_rules_quietly "-F ${CHAINFORWARDTRAFIC}-to-${dnatPORTC[1]}" & pids+=($!)

	done

	wait "${pids[@]}"
	return 0
}

# insert_rules_list_ports "-t " "-AI" "-m ipv4" "-m ipv6" "-j" "tcp/udp" ARRAY
insert_rules_list_ports()
{
	local cmd_args_v4=""
	local cmd_args_v6=""
	local option_t=$1 #-t nat/
	shift
	cmd_args_v4+="$option_t"
	cmd_args_v6+="$option_t"
	local option_A_I=$1 #-A ?/-I ?
	shift
	cmd_args_v4+=" $option_A_I"
	cmd_args_v6+=" $option_A_I"
	local option_m_v4=$1 #-m set ! --match-set ${IPSLISTBADIP} src
	shift
	if [ ! -z "$option_m_v4" ]; then
		cmd_args_v4+=" $option_m_v4"
	fi
	local option_m_v6=$1 #-m set ! --match-set ${IPSLISTBADIP}6 src
	shift
	if [ ! -z "$cmd_args_v6" ]; then
		cmd_args_v6+=" $option_m_v6"
	fi
	local option_j=$1 #-j ACCEPT
	shift
	local proto=$1 #tcp/udp
	shift
	local ports=("$@")
	
	declare -a pids=()
	local PORT
	for PORT in "${ports[@]}"; do
		$IPT $cmd_args_v4 -p $proto --dport $PORT $option_j & pids+=($!)
		$IPT6 $cmd_args_v6 -p $proto --dport $PORT $option_j & pids+=($!)
	done
	wait "${pids[@]}"
	return 0
}

# insert_rules_list_redirections "-AI NAT" "-AI FILTER" "-m ipv4" "-m ipv6" "-j FILTER" "tcp/udp" ARRAY
insert_rules_list_redirections()
{
	local cmd_args_v4_nat="-t nat"
	local cmd_args_v6_nat="-t nat"
	local cmd_args_v4_nat_log="-t nat"
	local cmd_args_v6_nat_log="-t nat"
	local cmd_args_v4_filter="-t filter"
	local cmd_args_v6_filter="-t filter"
	local option_A_I_nat=$1 #-A ?/-I ?
	shift
	cmd_args_v4_nat+=" $option_A_I_nat"
	cmd_args_v6_nat+=" $option_A_I_nat"
	cmd_args_v4_nat_log+=" ${option_A_I_nat}-logs"
	cmd_args_v6_nat_log+=" ${option_A_I_nat}-logs"
	local option_A_I_filter=$1 #-A ?/-I ?
	shift
	cmd_args_v4_filter+=" $option_A_I_filter"
	cmd_args_v6_filter+=" $option_A_I_filter"
	local option_m_v4=$1 #-m set ! --match-set ${IPSLISTBADIP} src
	shift
	if [ ! -z "$option_m_v4" ]; then
		cmd_args_v4_nat+=" $option_m_v4"
		cmd_args_v4_nat_log+=" $option_m_v4"
		cmd_args_v4_filter+=" $option_m_v4"
	fi
	local option_m_v6=$1 #-m set ! --match-set ${IPSLISTBADIP}6 src
	shift
	if [ ! -z "$cmd_args_v6" ]; then
		cmd_args_v6_nat+=" $option_m_v6"
		cmd_args_v6_nat_log+=" $option_m_v6"
		cmd_args_v6_filter+=" $option_m_v6"
	fi
	local option_j=$1 #-j ACCEPT
	shift
	local proto=$1 #tcp/udp
	shift
	local redirectPorts=("$@")
	
	declare -a pids=()
	local PORTS
	local PORTSC
	for PORTS in "${redirectPorts[@]}"; do
		IFS=',' read -r -a PORTSC <<< $PORTS
		$IPT $cmd_args_v4_filter -p $proto --dport ${PORTSC[1]} $option_j & pids+=($!)
		$IPT6 $cmd_args_v6_filter -p $proto --dport ${PORTSC[1]} $option_j & pids+=($!)

		# -j LOG --log-prefix "[iptables-forward]: " 
		$IPT $cmd_args_v4_nat_log -p $proto --dport ${PORTSC[0]} -g ${CHAINPATLOG} && $IPT $cmd_args_v4_nat -p $proto --dport ${PORTSC[0]} -j REDIRECT --to-port ${PORTSC[1]} & pids+=($!)
		$IPT6 $cmd_args_v6_nat_log -p $proto --dport ${PORTSC[0]} -g ${CHAINPATLOG} && $IPT6 $cmd_args_v6_nat -p $proto --dport ${PORTSC[0]} -j REDIRECT --to-port ${PORTSC[1]} & pids+=($!)
	done
	wait "${pids[@]}"
	return 0
}

# insert_rules_list_dnat "-AI" "-m ipv4" "-m ipv6" "tcp/udp" ARRAY
insert_rules_list_dnat()
{
	local cmd_args_v4="-t nat"
	local cmd_args_v6="-t nat"
	local cmd_args_v4_nat_log="-t nat"
	local cmd_args_v6_nat_log="-t nat"
	local option_A_I=$1 #-A ?/-I ?
	shift
	cmd_args_v4+=" $option_A_I"
	cmd_args_v6+=" $option_A_I"
	cmd_args_v4_nat_log+=" ${option_A_I}-logs"
	cmd_args_v6_nat_log+=" ${option_A_I}-logs"
	local option_m_v4=$1 #-m set ! --match-set ${IPSLISTBADIP} src
	shift
	if [ ! -z "$option_m_v4" ]; then
		cmd_args_v4+=" $option_m_v4"
		cmd_args_v4_nat_log+=" $option_m_v4"
	fi
	local option_m_v6=$1 #-m set ! --match-set ${IPSLISTBADIP}6 src
	shift
	if [ ! -z "$cmd_args_v6" ]; then
		cmd_args_v6+=" $option_m_v6"
		cmd_args_v6_nat_log+=" $option_m_v6"
	fi
	local proto=$1 #tcp/udp
	shift
	local dnatPorts=("$@")
	
	declare -a pids=()
	local dnatPORT
	local dnatPORTC
	for dnatPORT in "${dnatPorts[@]}"; do
		# "portIN,interOUT,IPv4,IPv6,portTarget"
		IFS=',' read -r -a dnatPORTC <<< $dnatPORT
		$IPT $cmd_args_v4_nat_log -p $proto --dport ${dnatPORTC[0]} -g ${CHAINPATLOG} && $IPT $cmd_args_v4 -p $proto --dport ${dnatPORTC[0]} -j DNAT --to-destination ${dnatPORTC[2]}:${dnatPORTC[4]} & pids+=($!)
		if [ ! -z "${dnatPORTC[3]}" ]; then
			$IPT6 $cmd_args_v6_nat_log -p $proto --dport ${dnatPORTC[0]} -g ${CHAINPATLOG} && $IPT6 $cmd_args_v6 -p $proto --dport ${dnatPORTC[0]} -j DNAT --to-destination ${dnatPORTC[3]}:${dnatPORTC[4]} & pids+=($!)
		fi
	done
	wait "${pids[@]}"
	return 0
}

insert_rules_list_dnat_forward()
{
	local proto=$1 #tcp/udp
	shift
	local dnatPorts=("$@")
	
	local dnatPORT
	local dnatPORTC
	for dnatPORT in "${dnatPorts[@]}"; do
		declare -a pids=()
		# "portIN,interOUT,IPv4,IPv6,portTarget"
		IFS=',' read -r -a dnatPORTC <<< $dnatPORT
		if [ ! -z "${dnatPORTC[1]}" ]; then
			insert_rules_quietly "-N ${CHAINFORWARDTRAFIC}-from-${dnatPORTC[1]}"
			insert_rules_quietly "-N ${CHAINFORWARDTRAFIC}-to-${dnatPORTC[1]}"
			if [ ! -z "${dnatPORTC[2]}" ]; then
				$IPT -C ${CHAINFORWARDTRAFIC}-to-${dnatPORTC[1]} ! -i ${dnatPORTC[1]} -p $proto --dport ${dnatPORTC[4]} -d ${dnatPORTC[2]} -j ACCEPT 2> /dev/null || $IPT -A ${CHAINFORWARDTRAFIC}-to-${dnatPORTC[1]} ! -i ${dnatPORTC[1]} -p $proto --dport ${dnatPORTC[4]} -d ${dnatPORTC[2]} -j ACCEPT & pids+=($!)
				$IPT -C ${CHAINFORWARDTRAFIC}-from-${dnatPORTC[1]} ! -o ${dnatPORTC[1]} -p $proto --sport ${dnatPORTC[4]} -s ${dnatPORTC[2]} -j ACCEPT 2> /dev/null || $IPT -A ${CHAINFORWARDTRAFIC}-from-${dnatPORTC[1]} ! -o ${dnatPORTC[1]} -p $proto --sport ${dnatPORTC[4]} -s ${dnatPORTC[2]} -j ACCEPT & pids+=($!)
			fi
			if [ ! -z "${dnatPORTC[3]}" ]; then
				$IPT6 -C ${CHAINFORWARDTRAFIC}-to-${dnatPORTC[1]} ! -i ${dnatPORTC[1]} -p $proto --dport ${dnatPORTC[4]} -d ${dnatPORTC[3]} -j ACCEPT 2> /dev/null || $IPT6 -A ${CHAINFORWARDTRAFIC}-to-${dnatPORTC[1]} ! -i ${dnatPORTC[1]} -p $proto --dport ${dnatPORTC[4]} -d ${dnatPORTC[3]} -j ACCEPT & pids+=($!)
				$IPT6 -C ${CHAINFORWARDTRAFIC}-from-${dnatPORTC[1]} ! -o ${dnatPORTC[1]} -p $proto --sport ${dnatPORTC[4]} -s ${dnatPORTC[3]} -j ACCEPT 2> /dev/null || $IPT6 -A ${CHAINFORWARDTRAFIC}-from-${dnatPORTC[1]} ! -o ${dnatPORTC[1]} -p $proto --sport ${dnatPORTC[4]} -s ${dnatPORTC[3]} -j ACCEPT & pids+=($!)
			fi
		fi
		wait "${pids[@]}"
	done
	return 0
}

# insert_rules_list_docker "-AI" "-m ipv4" "-m ipv6" "tcp/udp" ARRAY
insert_rules_list_docker()
{
	local cmd_args_v4="-t nat"
	local cmd_args_v6="-t nat"
	local cmd_args_v4_nat_log="-t nat"
	local cmd_args_v6_nat_log="-t nat"
	local option_A_I=$1 #-A ?/-I ?
	shift
	cmd_args_v4+=" $option_A_I"
	cmd_args_v6+=" $option_A_I"
	cmd_args_v4_nat_log+=" ${option_A_I}-logs"
	cmd_args_v6_nat_log+=" ${option_A_I}-logs"
	local option_m_v4=$1 #-m set ! --match-set ${IPSLISTBADIP} src
	shift
	if [ ! -z "$option_m_v4" ]; then
		cmd_args_v4+=" $option_m_v4"
		cmd_args_v4_nat_log+=" $option_m_v4"
	fi
	local option_m_v6=$1 #-m set ! --match-set ${IPSLISTBADIP}6 src
	shift
	if [ ! -z "$cmd_args_v6" ]; then
		cmd_args_v6+=" $option_m_v6"
		cmd_args_v6_nat_log+=" $option_m_v6"
	fi
	local proto=$1 #tcp/udp
	shift
	local containersDNAT=("$@")
	
	declare -a pids=()
	local containerDNAT
	local containerDNATC
	for containerDNAT in "${containersDNAT[@]}"; do
		# "portIN,interOUT,container,portTarget"
		IFS=',' read -r -a containerDNATC <<< $containerDNAT
		local ipv4=$(${DOCKER} container inspect -f "{{ .NetworkSettings.Networks.${containerDNATC[1]}.IPAddress }}" ${containerDNATC[2]})
		if [ ! -z "${ipv4}" ]; then
			$IPT $cmd_args_v4_nat_log -p $proto --dport ${containerDNATC[0]} -g ${CHAINPATLOG} && $IPT $cmd_args_v4 -p $proto --dport ${containerDNATC[0]} -j DNAT --to-destination ${ipv4}:${containerDNATC[3]} & pids+=($!)
		fi
		local ipv6=$(${DOCKER} container inspect -f "{{ .NetworkSettings.Networks.${containerDNATC[1]}.GlobalIPv6Address }}" ${containerDNATC[2]})
		if [ ! -z "${ipv6}" ]; then
			$IPT6 $cmd_args_v6_nat_log -p $proto --dport ${containerDNATC[0]} -g ${CHAINPATLOG} && $IPT6 $cmd_args_v6 -p $proto --dport ${containerDNATC[0]} -j DNAT --to-destination ${ipv6}:${containerDNATC[3]} & pids+=($!)
		fi
	done
	wait "${pids[@]}"
	return 0
}

insert_rules_list_docker_forward()
{
	local proto=$1 #tcp/udp
	shift
	local containersDNAT=("$@")
	
	local containerDNAT
	local containerDNATC
	for containerDNAT in "${containersDNAT[@]}"; do
		declare -a pids=()
		# "portIN,interOUT,container,portTarget"
		IFS=',' read -r -a containerDNATC <<< $containerDNAT
		if [ ! -z "${containerDNATC[1]}" ]; then
			insert_rules_quietly "-N ${CHAINFORWARDTRAFIC}-from-${containerDNATC[1]}"
			insert_rules_quietly "-N ${CHAINFORWARDTRAFIC}-to-${containerDNATC[1]}"
			local ipv4=$(${DOCKER} container inspect -f "{{ .NetworkSettings.Networks.${containerDNATC[1]}.IPAddress }}" ${containerDNATC[2]})
			if [ ! -z "${ipv4}" ]; then
				$IPT -C ${CHAINFORWARDTRAFIC}-to-${containerDNATC[1]} ! -i ${containerDNATC[1]} -p $proto --dport ${containerDNATC[3]} -d ${ipv4} -j ACCEPT 2> /dev/null || $IPT -A ${CHAINFORWARDTRAFIC}-to-${containerDNATC[1]} ! -i ${containerDNATC[1]} -p $proto --dport ${containerDNATC[3]} -d ${ipv4} -j ACCEPT & pids+=($!)
				$IPT -C ${CHAINFORWARDTRAFIC}-from-${containerDNATC[1]} ! -o ${containerDNATC[1]} -p $proto --sport ${containerDNATC[3]} -s ${ipv4} -j ACCEPT 2> /dev/null || $IPT -A ${CHAINFORWARDTRAFIC}-from-${containerDNATC[1]} ! -o ${containerDNATC[1]} -p $proto --sport ${containerDNATC[3]} -s ${ipv4} -j ACCEPT & pids+=($!)
			fi
			local ipv6=$(${DOCKER} container inspect -f "{{ .NetworkSettings.Networks.${containerDNATC[1]}.GlobalIPv6Address }}" ${containerDNATC[2]})
			if [ ! -z "${ipv6}" ]; then
				echo "${containerDNAT} ${ipv6}"
				$IPT6 -C ${CHAINFORWARDTRAFIC}-to-${containerDNATC[1]} ! -i ${containerDNATC[1]} -p $proto --dport ${containerDNATC[3]} -d ${ipv6} -j ACCEPT 2> /dev/null || $IPT6 -A ${CHAINFORWARDTRAFIC}-to-${containerDNATC[1]} ! -i ${containerDNATC[1]} -p $proto --dport ${containerDNATC[3]} -d ${ipv6} -j ACCEPT & pids+=($!)
				$IPT6 -C ${CHAINFORWARDTRAFIC}-from-${containerDNATC[1]} ! -o ${containerDNATC[1]} -p $proto --sport ${containerDNATC[3]} -s ${ipv6} -j ACCEPT 2> /dev/null || $IPT6 -A ${CHAINFORWARDTRAFIC}-from-${containerDNATC[1]} ! -o ${containerDNATC[1]} -p $proto --sport ${containerDNATC[3]} -s ${ipv6} -j ACCEPT & pids+=($!)
			fi
		fi
		wait "${pids[@]}"
	done
	return 0
}

insert_rules_with_test_ok_ipv4()
{
	local cmd_args=$1 # -t nat -I ? -m ? -j ?
	local cmd_args_back=$2
	local i=0
	$IPT $cmd_args > /dev/null 2>&1
	while [ $? -ne 0 ] && [ $i -le 5 ]; do
		((i++))
		sleep 1
		$IPT $cmd_args >/dev/null 2>&1
	done
	if [ $? -ne 0 ]; then
		$IPT $cmd_args
		echo "Bugged v4 $cmd_args"
		if [ ! -z "$cmd_args_back" ]; then
			$IPT $cmd_args_back
		fi
	fi
	return 0
}

insert_rules_with_test_ok_ipv6()
{
	local cmd_args=$1 # -t nat -I ? -m ? -j ?
	local cmd_args_back=$2
	local i=0
	$IPT6 $cmd_args > /dev/null 2>&1
	while [ $? -ne 0 ] && [ $i -le 5 ]; do
		((i++))
		sleep 1
		$IPT6 $cmd_args >/dev/null 2>&1
	done
	if [ $? -ne 0 ]; then
		$IPT6 $cmd_args
		echo "Bugged v6 $cmd_args"
		if [ ! -z "$cmd_args_back" ]; then
			$IPT6 $cmd_args_back
		fi
	fi
	return 0
}

insert_rules_with_test_ok()
{
	local cmd_args=$1 # -t nat -I ? -m ? -j ?
	local cmd_args_back=$2
	local pid1
	local pid2
	insert_rules_with_test_ok_ipv4 "$cmd_args" "$cmd_args_back" & pid1=$!
	insert_rules_with_test_ok_ipv6 "$cmd_args" "$cmd_args_back" & pid2=$!
	wait $pid1
	wait $pid2
	return 0
}

generate_set_ip_net()
{
	local INTERS=("$@") # inter,net/mask,net6/mask
	declare -a pids=()
	declare -A netOK=()
	local INTER
	local INTERC
	for INTER in "${INTERS[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		if [ ! -z "${INTERC[1]}" ]; then
			if [ ! -v netOK[${INTERC[1]}] ]; then
				netOK[${INTERC[1]}]=0
				# On fait un set des IPS car plus rapide pour le traitement
				{ $IPS destroy ${INTERC[1]} 2> /dev/null; $IPS create ${INTERC[1]} hash:ip maxelem 999999999 2> /dev/null; } & pids+=($!)
			fi
		fi
		if [ ! -z "${INTERC[2]}" ]; then
			if [ ! -v netOK[${INTERC[2]}] ]; then
				netOK[${INTERC[2]}]=0
				# On fait un set des IPS car plus rapide pour le traitement
				{ $IPS destroy ${INTERC[2]} 2> /dev/null; $IPS create ${INTERC[2]} hash:ip maxelem 999999999 family inet6 2> /dev/null; } & pids+=($!)
			fi
		fi
	done
	wait "${pids[@]}"
}

insert_set_ip_net()
{
	local INTERS=("$@") # inter,net/mask,net6/mask
	declare -a pids=()
	declare -A netOK=()
	local INTER
	local INTERC
	for INTER in "${INTERS[@]}"; do
		IFS=';' read -r -a INTERC <<< $INTER
		if [ ! -z "${INTERC[1]}" ]; then
			if [ ! -v netOK[${INTERC[1]}] ]; then
				netOK[${INTERC[1]}]=0
				$IPS add ${INTERC[1]} ${INTERC[1]} 2> /dev/null & pids+=($!)
			fi
		fi
		if [ ! -z "${INTERC[2]}" ]; then
			if [ ! -v netOK[${INTERC[2]}] ]; then
				netOK[${INTERC[2]}]=0
				$IPS add ${INTERC[2]} ${INTERC[2]} 2> /dev/null & pids+=($!)
			fi
		fi
	done
	wait "${pids[@]}"
}

insert_rules_nat_forward_interface()
{
	local INTER=$1 # inter,net/mask,net6/mask
	declare -a pids=()
	local INTERC
	IFS=';' read -r -a INTERC <<< $INTER
	# $IPT -t nat -A $CHAINPOSTROUTINGNAT ! -o ${INTERC[0]} -s ${INTERC[1]} ! -d ${INTERC[1]} -j MASQUERADE & pids+=($!)
	
	insert_rules_quietly "-N ${CHAINFORWARDTRAFIC}-from-${INTERC[0]}"
	insert_rules_quietly "-N ${CHAINFORWARDTRAFIC}-to-${INTERC[0]}"
	if [ ! -z "${INTERC[1]}" ]; then
		$IPT -I ${CHAINFORWARDTRAFIC}-from-${INTERC[0]} 1 -o $mainInter -m set --match-set ${INTERC[1]} src -m set ! --match-set ${INTERC[1]} dst -j ACCEPT & pids+=($!)
		$IPT -I ${CHAINFORWARDTRAFIC}-to-${INTERC[0]} 1 ! -i ${INTERC[0]} -m set ! --match-set ${INTERC[1]} src -m set --match-set ${INTERC[1]} dst -m state --state ESTABLISHED,RELATED -j ACCEPT & pids+=($!)
	fi
	if [ ! -z "${INTERC[2]}" ]; then
		# $IPT6 -t nat -A $CHAINPOSTROUTINGNAT ! -o ${INTERC[0]} -s ${INTERC[2]} ! -d ${INTERC[2]} -j MASQUERADE & pids+=($!)
		$IPT6 -I ${CHAINFORWARDTRAFIC}-from-${INTERC[0]} 1 -o $mainInter -m set --match-set ${INTERC[2]} src -m set ! --match-set ${INTERC[2]} dst -j ACCEPT & pids+=($!)
		$IPT6 -I ${CHAINFORWARDTRAFIC}-to-${INTERC[0]} 1 ! -i ${INTERC[0]} -m set ! --match-set ${INTERC[2]} src -m set --match-set ${INTERC[2]} dst -m state --state ESTABLISHED,RELATED -j ACCEPT & pids+=($!)
	fi
	wait "${pids[@]}"
	return 0
}

insert_rules_accept_trafic_local_interface()
{
	local INTER=$1 # inter,net/mask,net6/mask
	declare -a pids=()
	local INTERC
	IFS=';' read -r -a INTERC <<< $INTER
	
	if [ -v interfaceWithDHCP["$INTER"] ] && [ "${interfaceWithDHCP[$INTER]}" -eq 1 ]; then
		local CHAINUDPUSE=$CHAINMAININTINTERUDPDHCP
		echo "Create the rules for internal interface $INTER with DHCP open"
	else
		local CHAINUDPUSE=$CHAINMAININTINTERUDP
		echo "Create the rules for internal interface $INTER with DHCP close"
	fi
	
	insert_rules_quietly "-N ${CHAINMAININTER}-${INTERC[0]}"
	insert_rules_quietly "-t nat -N ${CHAINMAININTER}-${INTERC[0]}"
	
	if [ ! -z "${INTERC[1]}" ]; then
		local pid1
		# On utilise un set des IPS car plus rapide pour le traitement
		$IPT -N ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null

		$IPT -A ${CHAINMAININTER}-${INTERC[0]} -m set --match-set ${INTERC[1]} src -g ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} & pids+=($!)
		
		$IPT -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p icmp -g $CHAINMAININTINTERICMP && \
			insert_rules_with_test_ok_ipv4 "-A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -m set --match-set $IPSLISTBADIP src -j DROP" "" && \
			$IPT -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p tcp -g $CHAINMAININTINTERTCP && \
			$IPT -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p udp -g $CHAINUDPUSE & pids+=($!)
		
		$IPT -t nat -N ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null
		
		$IPT -t nat -A ${CHAINMAININTER}-${INTERC[0]} -m set --match-set ${INTERC[1]} src -g ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} & pids+=($!)
		
		insert_rules_with_test_ok_ipv4 "-t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -m set --match-set $IPSLISTBADIP src -j RETURN" "" && \
			$IPT -t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p tcp -g $CHAINMAININTINTERTCP && \
			$IPT -t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p udp -g $CHAINUDPUSE & pids+=($!)
	fi
	if [ ! -z "${INTERC[2]}" ]; then
		local pid1
		# On utilise un set des IPS car plus rapide pour le traitement
		$IPT6 -N ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null

		$IPT6 -A ${CHAINMAININTER}-${INTERC[0]} -m set --match-set ${INTERC[2]} src -g ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} & pids+=($!)
		
		$IPT6 -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p ipv6-icmp -g $CHAINMAININTINTERICMP && \
			insert_rules_with_test_ok_ipv6 "-A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -m set --match-set ${IPSLISTBADIP}6 src -j DROP" "" && \
			$IPT6 -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p tcp -g $CHAINMAININTINTERTCP && \
			$IPT6 -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p udp -g $CHAINUDPUSE & pids+=($!)
	
		$IPT6 -t nat -N ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null
		
		$IPT6 -t nat -A ${CHAINMAININTER}-${INTERC[0]} -m set --match-set ${INTERC[2]} src -g ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} & pids+=($!)
		
		insert_rules_with_test_ok_ipv6 "-t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -m set --match-set ${IPSLISTBADIP}6 src -j RETURN" "" && \
			$IPT6 -t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p tcp -g $CHAINMAININTINTERTCP && \
			$IPT6 -t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p udp -g $CHAINUDPUSE & pids+=($!)
	fi
	wait "${pids[@]}"
	return 0
}

insert_rules_accept_trafic_local_out_interface()
{
	local INTER=$1 # inter,net/mask,net6/mask
	declare -a pids=()
	local INTERC
	IFS=';' read -r -a INTERC <<< $INTER
	
	if [ -v interfaceWithDHCP["$INTER"] ] && [ "${interfaceWithDHCP[$INTER]}" -eq 1 ]; then
		local CHAINUDPUSE=$CHAINOPENLOCALPORTUDPDHCP
		echo "Create the rules for internal interface $INTER with DHCP open"
	else
		local CHAINUDPUSE=$CHAINOPENLOCALPORTUDP
		echo "Create the rules for internal interface $INTER with DHCP close"
	fi
	
	insert_rules_quietly "-N ${CHAINMAININTER}-${INTERC[0]}"
	insert_rules_quietly "-t nat -N ${CHAINMAININTER}-${INTERC[0]}"
	
	if [ ! -z "${INTERC[1]}" ]; then
		# On utilise un set des IPS car plus rapide pour le traitement
		$IPT -N ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null

		$IPT -A ${CHAINMAININTER}-${INTERC[0]} -m set --match-set ${INTERC[1]} src -g ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} & pids+=($!)
		
		$IPT -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p icmp -g $CHAINMAININTINTERICMP && \
			insert_rules_with_test_ok_ipv4 "-A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -m set --match-set $IPSLISTBADIP src -j DROP" "" && \
			$IPT -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p tcp -g $CHAINOPENLOCALPORTTCP && \
			$IPT -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p udp -g $CHAINUDPUSE & pids+=($!)
		
		$IPT -t nat -N ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} 2> /dev/null

		$IPT -t nat -A ${CHAINMAININTER}-${INTERC[0]} -m set --match-set ${INTERC[1]} src -g ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} & pids+=($!)
		
		insert_rules_with_test_ok_ipv4 "-t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -m set --match-set $IPSLISTBADIP src -j RETURN" "" && \
			$IPT -t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p tcp -g $CHAINOPENLOCALPORTTCP && \
			$IPT -t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[1]} -p udp -g $CHAINUDPUSE & pids+=($!)
	fi
	if [ ! -z "${INTERC[2]}" ]; then
		# On fait un set des IPS car plus rapide pour le traitement
		$IPT6 -N ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null

		$IPT6 -A ${CHAINMAININTER}-${INTERC[0]} -m set --match-set ${INTERC[2]} src -g ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} & pids+=($!)
		
		$IPT6 -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p ipv6-icmp -g $CHAINMAININTINTERICMP && \
			insert_rules_with_test_ok_ipv6 "-A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -m set --match-set ${IPSLISTBADIP}6 src -j DROP" "" && \
			$IPT6 -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p tcp -g $CHAINOPENLOCALPORTTCP && \
			$IPT6 -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p udp -g $CHAINUDPUSE & pids+=($!)
	
		$IPT6 -t nat -N ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} 2> /dev/null

		$IPT6 -t nat -A ${CHAINMAININTER}-${INTERC[0]} -m set --match-set ${INTERC[2]} src -g ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} & pids+=($!)
		
		insert_rules_with_test_ok_ipv6 "-t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -m set --match-set ${IPSLISTBADIP}6 src -j RETURN" "" && \
			$IPT6 -t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p tcp -g $CHAINOPENLOCALPORTTCP && \
			$IPT6 -t nat -A ${CHAINMAININTER}-${INTERC[0]}-${INTERC[2]} -p udp -g $CHAINUDPUSE & pids+=($!)
	fi
	wait "${pids[@]}"
	return 0
}

insert_rules_accept_trafic_out_interface()
{
	local INTER=$1
	declare -a pids=()
	#echo "Create the rules for external interface $INTER"
	insert_rules_with_test_ok "-A ${CHAINMAININTER}-${INTER} -m geoip --src-cc $countryOpenPort -g $CHAINMAINOUTINTERCR" "" && \
		$IPT -A ${CHAINMAININTER}-${INTER} ! -s 0.0.0.0 -g $CHAINMAINOUTINTERWW && \
		$IPT6 -A ${CHAINMAININTER}-${INTER} -m addrtype ! --dst-type MULTICAST -g $CHAINMAINOUTINTERWW & pids+=($!)
		
	insert_rules_with_test_ok "-t nat -A ${CHAINMAININTER}-${INTER} -m geoip --src-cc $countryOpenPort -g $CHAINMAINOUTINTERCR" "" && \
		$IPT -t nat -A ${CHAINMAININTER}-${INTER} ! -s 0.0.0.0 -g $CHAINMAINOUTINTERWW && \
		$IPT6 -t nat -A ${CHAINMAININTER}-${INTER} -m addrtype ! --src-type MULTICAST -g $CHAINMAINOUTINTERWW & pids+=($!)
	
	insert_rules "-A OUTPUT -o $INTER -g $CHAINOUTTRAFIC" & pids+=($!)

	wait "${pids[@]}"
	return 0
}

insert_rules_end_interfaces()
{
	local INTER=$1
	declare -a pids=()
	insert_rules "-A INPUT -i ${INTER} -g ${CHAINMAININTER}-${INTER}" & pids+=($!)
	insert_rules "-t nat -A $CHAINPATMAIN -i ${INTER} -g ${CHAINMAININTER}-${INTER}" & pids+=($!)
	
	# Ajouter les règles iptables/ip6tables pour autoriser l'accès aux ports DHCP (UDP 67 et 547) de manière sécurisée
	if [ -v interfaceDHCP["$INTER"] ] && [ "${interfaceDHCP[${INTER}]}" -eq 1 ]; then
		# Ajouter la règle iptables pour DHCPv4 (port 67) avec IP source 0.0.0.0/0 et port source 68
		$IPT -A ${CHAINMAININTER}-${INTER} -p udp -s 0.0.0.0 --sport 68 --dport 67 -j $CHAINOPENDHCP
		
		# Ajouter la règle ip6tables pour DHCPv6 (port 547) avec IP source fe80::/64 et port source 546
		$IPT6 -A ${CHAINMAININTER}-${INTER} -p udp -m addrtype --dst-type MULTICAST --sport 546 --dport 547 -j ACCEPT
	fi
	
	$IPT6 -A ${CHAINMAININTER}-${INTER} -p ipv6-icmp -m addrtype --dst-type MULTICAST -j ACCEPT && \
		insert_rules "-A ${CHAINMAININTER}-${INTER} -j $CHAINDROPLOG" & pids+=($!)
	wait "${pids[@]}"
	return 0
}

close_traffic_list()
{
	declare -a pids=()
	local args_src=$1 # -k src
	shift
	local args_dst=$1 # -6 -k dst
	shift
	local listIPs=("$@")
	for IP in "${listIPs[@]}"; do
		$DUMPCO $args_src $IP > /dev/null 2>&1 & pids+=($!)
		$DUMPCO $args_dst $IP > /dev/null 2>&1 & pids+=($!)
	done
	wait "${pids[@]}"
	return 0
}

close_traffic()
{
	declare -a pids=()
	# Suppression des connexion du groupe IPV4s Bloques
	mapfile -t IPBlock < /etc/firewall/firewall.block.ip
	declare -a IPBlock
	close_traffic_list "-k src" "-k dst" $IPBlock & pids+=($!)
	
	wait "${pids[@]}"
	return 0
}

command="$1"
case "$command" in
        start|force-start)
				/bin/bash /etc/firewall/firewall.set.ip &
                set_rules
                ;;

        stop)
				echo "If you want clean rules, ask me clean !"
				;;

		restart|force-restart|reload|force-reload)
				/bin/bash /etc/firewall/firewall.set.ip &
				# On réinitialise le firewall
				flush_rules
				set_rules
				;;

		all-restart)
				/bin/bash /etc/firewall/firewall.set.ip &
				/bin/bash /etc/firewall/firewall.clean.block.ip &
				flush_rules
				set_rules
				;;

		reload-rules)
				flush_rules
				set_rules
				;;

		clean)
                delete_rules
                ;;

        status)
			$IPT -L INPUT -v -n
			$IPT -L FORWARD -v -n
			$IPT -L OUTPUT -v -n
			$IPT6 -L INPUT -v -n
			$IPT6 -L FORWARD -v -n
			$IPT6 -L OUTPUT -v -n
			;;
        *)
wait
esac

#update-rc.d firewall defaults;
